// Generated by LiveScript 1.3.1
(function(){
  var url, logger, utils, statusMap, Context, toString$ = {}.toString, slice$ = [].slice;
  url = require('url');
  logger = require('./logger');
  utils = require('./utils');
  statusMap = {
    404: 'Not found.',
    405: 'Method not allowed.',
    502: 'Server Error.'
  };
  Context = (function(){
    Context.displayName = 'Context';
    var prototype = Context.prototype, constructor = Context;
    function Context(req, resp, config){
      var urlObj;
      this.req = req;
      this.resp = resp;
      urlObj = url.parse(req.url);
      this.url = req.url;
      this.search = urlObj.search;
      this.query = urlObj.query;
      this.pathname = urlObj.pathname;
      this.queryParams = utils.queryStrToObj(urlObj.query);
      this.headers = req.headers;
      this.cookies = utils.parseCookie(req.headers.cookie);
      this.params = {};
      this.form = {};
      this.body = '';
      this._respHeaders = {};
      this._respCookies = {};
      this._respCharset = 'UTF-8';
    }
    prototype.setCharset = function(_respCharset){
      this._respCharset = _respCharset;
    };
    prototype.setHeader = function(key, value){
      var obj;
      obj = key;
      if (toString$.call(key).slice(8, -1) !== 'Object') {
        obj = {};
        obj[key] = value;
      }
      import$(this._respHeaders, obj);
    };
    prototype.setCookie = function(key, value, opt){
      var header, exDate;
      opt = import$({
        path: '/',
        expires: 30,
        domain: undefined,
        httpOnly: true,
        secure: false,
        overwrite: false
      }, opt);
      header = key + '=' + value;
      if (opt.path) {
        header += '; path=' + opt.path;
      }
      if (opt.expires) {
        exDate = new Date;
        exDate.setDate(exDate.getDate() + opt.expires);
        header += '; expires=' + exDate.toUTCString();
      }
      if (opt.domain) {
        header += '; domain' + opt.domain;
      }
      if (opt.secure) {
        header += '; secure';
      }
      if (opt.httpOnly) {
        header += '; httponly';
      }
      this._respCookies[key] = header;
    };
    prototype.setSecureCookie = function(key, value, opt){
      var that;
      if (that = config.cookieSecureToken) {
        value = utils.encodeStr(that, value);
      }
      this.setCookie(key, value, opt);
    };
    prototype.send = function(){
      var args, statusCode, content, ref$, cookieAcc, _, item;
      args = slice$.call(arguments);
      statusCode = args[0], content = args[1];
      if (!content) {
        ref$ = [200, statusCode], statusCode = ref$[0], content = ref$[1];
      }
      cookieAcc = [];
      for (_ in ref$ = this._respCookies) {
        item = ref$[_];
        cookieAcc.push(item);
      }
      import$(this._respHeaders, {
        'Set-Cookie': cookieAcc
      });
      this.resp.writeHead(statusCode, this._respHeaders);
      this.resp.end(content);
    };
    prototype.json = function(obj){
      var str, message, error;
      this.setHeader('Content-Type', 'application/json; charset=' + this._respCharset);
      try {
        str = JSON.stringify(obj);
      } catch (e$) {
        message = e$.message;
        error = 'response.json require a Object param can be stringified to string';
        logger.error(error);
        return;
      }
      this.send(str);
    };
    prototype.html = function(str){
      this.setHeader('Content-Type', 'text/html; charset=' + this._respCharset);
      this.send(str);
    };
    prototype.sendStatus = function(statusCode){
      var that;
      if (that = statusMap[statusCode]) {
        this.send(statusCode, that);
      }
    };
    return Context;
  }());
  exports.Context = Context;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
