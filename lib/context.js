// Generated by LiveScript 1.3.1
(function(){
  var url, logger, utils, statusMap, Context, toString$ = {}.toString;
  url = require('url');
  logger = require('./logger');
  utils = require('./utils');
  statusMap = {
    404: 'Not found.',
    405: 'Method not allowed.',
    502: 'Server Error.'
  };
  Context = (function(){
    Context.displayName = 'Context';
    var prototype = Context.prototype, constructor = Context;
    function Context(req, resp, config, g){
      var urlObj;
      config == null && (config = {});
      g == null && (g = {});
      this.req = req;
      this.resp = resp;
      this.config = config;
      this.g = g;
      urlObj = url.parse(req.url);
      this.url = req.url;
      this.method = req.method;
      this.search = urlObj.search;
      this.query = urlObj.query;
      this.pathname = urlObj.pathname;
      this.queryParams = utils.queryStrToObj(urlObj.query);
      this.headers = req.headers;
      this.cookies = utils.parseCookie(req.headers.cookie);
      this.params = {};
      this.form = {};
      this.body = '';
      this.ip = (req.headers['x-forwarded-for'] || '').split(',')[0] || req.connection.remoteAddress;
      this._respHeaders = {};
      this._respCookies = {};
      this._respCharset = 'UTF-8';
    }
    prototype.setCharset = function(_respCharset){
      this._respCharset = _respCharset;
    };
    prototype.setHeader = function(key, value){
      var obj;
      obj = key;
      if (toString$.call(key).slice(8, -1) !== 'Object') {
        obj = {};
        obj[key] = value;
      }
      import$(this._respHeaders, obj);
    };
    prototype.setCookie = function(key, value, opt){
      var header, exDate;
      opt = import$({
        path: '/',
        expires: 30,
        domain: undefined,
        httpOnly: true,
        secure: false,
        overwrite: false
      }, opt);
      header = key + '=' + value;
      if (opt.path) {
        header += '; path=' + opt.path;
      }
      if (opt.expires) {
        exDate = new Date;
        exDate.setDate(exDate.getDate() + opt.expires);
        header += '; expires=' + exDate.toUTCString();
      }
      if (opt.domain) {
        header += '; domain' + opt.domain;
      }
      if (opt.secure) {
        header += '; secure';
      }
      if (opt.httpOnly) {
        header += '; httponly';
      }
      this._respCookies[key] = header;
    };
    prototype.setSecureCookie = function(key, value, opt){
      var signature;
      opt = import$({
        expires: 30
      }, opt);
      value = [value.length, utils.base64.encode(value), Date.now() + opt.expires * 60 * 60 * 24];
      signature = utils.hexHmacSha1(value.join('|', this.config.cookieSecureToken));
      value.push(signature);
      value = value.join('|').replace(/\=/g, '*');
      this.setCookie(key, value, opt);
    };
    prototype.getCookie = function(key, dft){
      return this.cookies[key] || dft;
    };
    prototype.getSecureCookie = function(key, dft){
      var value, parts, len, expires, signature, localSig;
      value = this.cookies[key];
      if (!value) {
        return dft;
      }
      parts = value.replace(/\*/g, '=').split('|');
      if (parts.length !== 4) {
        return dft;
      }
      len = parts[0], value = parts[1], expires = parts[2], signature = parts[3];
      value = utils.base64.decode(value).substr(0, len);
      if (+expires < Date.now()) {
        return dft;
      }
      localSig = utils.hexHmacSha1(parts.slice(0, 3).join('|'), this.config.cookieSecureToken);
      if (localSig !== signature) {
        logger.error('invalid cookie signature: ' + key);
        return dft;
      }
      return value;
    };
    prototype.send = function(statusCode, content){
      var ref$, cookieAcc, _, item;
      if (!content) {
        ref$ = [200, statusCode], statusCode = ref$[0], content = ref$[1];
      }
      cookieAcc = [];
      for (_ in ref$ = this._respCookies) {
        item = ref$[_];
        cookieAcc.push(item);
      }
      import$(this._respHeaders, {
        'Set-Cookie': cookieAcc
      });
      this.resp.writeHead(statusCode, this._respHeaders);
      this.resp.end(content);
    };
    prototype.json = function(statusCode, obj){
      var ref$, str, message, error;
      if (!obj) {
        ref$ = [200, statusCode], statusCode = ref$[0], obj = ref$[1];
      }
      this.setHeader('Content-Type', 'application/json; charset=' + this._respCharset);
      try {
        str = JSON.stringify(obj);
      } catch (e$) {
        message = e$.message;
        error = 'response.json require a Object param can be stringified to string';
        logger.error(error);
        return;
      }
      this.send(statusCode, str);
    };
    prototype.html = function(statusCode, str){
      var ref$;
      if (!str) {
        ref$ = [200, statusCode], statusCode = ref$[0], str = ref$[1];
      }
      this.setHeader('Content-Type', 'text/html; charset=' + this._respCharset);
      this.send(statusCode, str);
    };
    prototype.redirect = function(url){
      this.resp.writeHead(302, {
        'Location': url
      });
      this.resp.end();
    };
    prototype.sendStatus = function(statusCode){
      var that, ref$;
      if (that = (ref$ = this.config.statusHandlerMap) != null ? ref$[statusCode] : void 8) {
        that.call(this);
        return;
      }
      if (that = statusMap[statusCode]) {
        this.send(statusCode, that);
      }
    };
    return Context;
  }());
  exports.Context = Context;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
