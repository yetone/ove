// Generated by LiveScript 1.3.1
(function(){
  var _, url, utils, getPatternList, Router, slice$ = [].slice, toString$ = {}.toString;
  _ = require('prelude-ls');
  url = require('url');
  utils = require('./utils');
  getPatternList = function(){
    return [];
  };
  Router = (function(){
    Router.displayName = 'Router';
    var prototype = Router.prototype, constructor = Router;
    function Router(){
      var self, i$, ref$, len$, name;
      this.register = bind$(this, 'register', prototype);
      this.methodList = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];
      this.handlerList = [];
      self = this;
      for (i$ = 0, len$ = (ref$ = this.methodList).length; i$ < len$; ++i$) {
        name = ref$[i$];
        fn$(name);
      }
      function fn$(name){
        return self[name.toLowerCase()] = function(){
          var args;
          args = slice$.call(arguments);
          args.push([name.toUpperCase()]);
          self.register.apply(self, args);
        };
      }
    }
    prototype.register = function(pattern, handler, methodList){
      var arr, i$, len$, item;
      arr = [];
      switch (toString$.call(pattern).slice(8, -1)) {
      case 'Array':
        arr = pattern;
        break;
      case 'Object':
        arr = getPatternList(pattern);
        break;
      default:
        arr.push([pattern, handler, methodList]);
      }
      for (i$ = 0, len$ = arr.length; i$ < len$; ++i$) {
        item = arr[i$];
        pattern = item[0], handler = item[1], methodList = item[2];
        switch (toString$.call(methodList).slice(8, -1)) {
        case 'Array':
          methodList = methodList.map(fn$);
          break;
        case 'String':
          methodList = [methodList.toUpperCase()];
          break;
        default:
          methodList = ['GET'];
        }
        this.handlerList.push([pattern, handler, methodList]);
      }
      function fn$(method){
        return method.toUpperCase();
      }
    };
    prototype.route = function(ctx){
      var self, body, paramRe, pathname, matched, i$, ref$, len$, item, pattern, handler, methodList, paramNames, that, re, mArr, j$, len1$, idx, name;
      self = this;
      if (ctx.req.method === 'POST') {
        body = '';
        ctx.req.on('data', function(data){
          return body += data;
        });
      }
      paramRe = /:[^\/]+/g;
      pathname = url.parse(ctx.req.url).pathname;
      pathname = pathname.charAt(pathname.length - 1) === '/'
        ? pathname
        : pathname + '/';
      matched = false;
      for (i$ = 0, len$ = (ref$ = this.handlerList).length; i$ < len$; ++i$) {
        item = ref$[i$];
        pattern = item[0], handler = item[1], methodList = item[2];
        if (pattern.replace(/[\/\w:\*]/g, '')) {
          throw new Error('The router pattern is error: ' + pattern);
        }
        paramNames = (that = pattern.match(paramRe))
          ? that.map(fn$)
          : [];
        pattern = pattern.charAt(pattern.length - 1) === '/'
          ? pattern
          : pattern + '/';
        pattern = '^' + pattern + '$';
        pattern = pattern.replace(paramRe, '([^/]+)').replace(/\*/g, '[^\\/]*').replace(/\*\*/g, '.*').replace(/\//g, '\\/');
        re = new RegExp(pattern);
        mArr = pathname.match(re);
        if (!mArr) {
          continue;
        }
        matched = true;
        if (!in$(ctx.req.method, methodList)) {
          continue;
        }
        for (j$ = 0, len1$ = paramNames.length; j$ < len1$; ++j$) {
          idx = j$;
          name = paramNames[j$];
          ctx.params[name] = mArr[++idx];
        }
        if (ctx.req.method === 'POST') {
          ctx.req.on('end', fn1$);
          return;
        }
        handler.call(ctx);
        return;
      }
      if (matched) {
        ctx.sendStatus(405);
      } else {
        ctx.sendStatus(404);
      }
      function fn$(it){
        return it.slice(1);
      }
      function fn1$(){
        ctx.form = utils.queryStrToObj(body);
        return handler.call(ctx);
      }
    };
    return Router;
  }());
  module.exports = Router;
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
